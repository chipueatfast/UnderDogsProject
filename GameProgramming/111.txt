void GameObject::Rotation(float angel)
{
	setAngel(angel);
	D3DXMATRIX oldMatrix;
	sprite_handler->GetTransform(&oldMatrix);
	sprite_handler->SetTransform(&(_rotation*_translation));
	Render();
	sprite_handler->SetTransform(&oldMatrix);
}

void GameObject::Scale(D3DXVECTOR2 scale)
{
	setScale(scale);
	D3DXMATRIX oldMatrix;
	sprite_handler->GetTransform(&oldMatrix);
	sprite_handler->SetTransform(&(_scale*_translation));
	Render();
	sprite_handler->SetTransform(&oldMatrix);
}


// ham transform su dung de transform gameobj tren 1 frame;

// prob : transform thi` vi tri ve  cua obj se bi thay doi khi ve~ len scene
-> solution : position chi dung de check collis + camera . GameObj ve len scene = ham Translation
-> ham Render chi ve dua theo Rect + anchor point


void GameObject::setPosition(float x, float y)
{
	_position = D3DXVECTOR3(x, y, 0);
	D3DXMatrixTranslation(&_translation, x, y, 0);
}

void GameObject::setScale(D3DXVECTOR2 scale)
{
	D3DXMatrixScaling(&_scale, scale.x, scale.y, .0f);
}

cac ham  set Scale , Rotation se set lai ma tran scale/rotation cua game obj
void GameObject::Render(D3DXVECTOR3* AnchorPoint)
{
	RECT cameraSheet;
	cameraSheet.top = (_sprite->index() / _sprite->sprites_per_row())*_sprite->height() + 1;
	cameraSheet.bottom = cameraSheet.top + _sprite->height() + 1;
	cameraSheet.left = 2 + (_sprite->index()%_sprite->sprites_per_row())* _sprite->width();
	cameraSheet.right = cameraSheet.left + _sprite->width() - 2;

	if (AnchorPoint == NULL)
	{
		AnchorPoint = new D3DXVECTOR3(width / 2,height / 2, 0);
	}
	D3DXVECTOR3 position;

	sprite_handler->Draw(
		_sprite->image(),
		&cameraSheet,
		AnchorPoint,
		NULL,
		D3DCOLOR_XRGB(255, 255, 255)
	);

